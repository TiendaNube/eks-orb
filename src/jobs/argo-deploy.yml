description: Deploy the given Helm chart as an Argo Application to EKS Cluster

executor: << parameters.executor >>

parameters:
  executor:
    description: Executor to use for this job
    type: executor
    default: argo
  cluster-name:
    description: EKS cluster name
    type: string
  region:
    description: AWS region where the eks cluster is located
    type: string
  s3-chart-repo:
    description: Additional helm chart repository
    type: string
    default: tiendanube-charts
  chart:
    description: Chart that will be installed
    type: string
  release-name:
    description: Helm release name
    type: string
  values-file:
    description: Helm values file for the service deployment
    type: string
  namespace:
    description: Namespace where the chart will be installed
    type: string
  image-tag:
    description: Which image tag will be installed
    type: string
  args:
    description: args to be used as helm client args
    type: string
    default: ""
  checkout:
    description: Boolean for whether or not to checkout as a first step. Default is true.
    type: boolean
    default: true
  resource-name:
    description: The name of the resource to be used. For Argo Rollouts, this should be 'rollout'
    type: string
    default: 'rollout'
  set-path-annotation:
    description: |
      Path annotation
      Example: .spec.template.metadata.annotations.
    type: string
    default: '.spec.template.metadata.annotations.'
  helm-app-status-timeout:
    description: >
      The length of time to wait before ending the watch of Argo Application deployment (e.g. 1s, 2m, 3h)
      Must be a floating point number with an optional suffix: 's' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for days.
      A duration of 0 disables the associated timeout.
    type: string
    default: '1m'
  rollout-status:
    description: |
      Get the status of the rollout.
      This can only be used for resource types that are valid for usage with `kubectl rollout` subcommands.
    type: boolean
    default: true
  rollout-status-timeout:
    description: >
      The length of time to wait before ending the watch of Argo Rollout (e.g. 1s, 2m, 3h)
      Must be a floating point number with an optional suffix: 's' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for days.
      A duration of 0 (the default) disables the associated timeout, in order to wait until the rollout reaches a final state.
    type: string
    default: '0'
  mesh:
    default: false
    description: >
      check if enabled label istio on namespace
    type: boolean
  # New parameters for ArgoCD Application configuration
  destination-server:
    description: Kubernetes cluster URL
    type: string
    default: https://kubernetes.default.svc
  project:
    description: ArgoCD project name
    type: string
    default: tiendanube
  # New parameters for ArgoCD migration workflow
  argocd-migration-feedback-timeout:
    description: >
      The maximum time to wait for user feedback during the ArgoCD migration workflow (e.g. 1s, 2m, 3h).
      Must be a floating point number with an optional suffix: 's' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for days.
      A duration of 0 (the default) disables the associated timeout, in order to wait until the migration finishes.
    type: string
    default: '0'
  argocd-migration-workflow-enabled:
    description: >
      Enable the ArgoCD migration workflow.
    type: boolean
    default: true

steps:
  - run:
      name: Computing Environment Variables
      command: |
        REPOSITORY_HTTP_URL=$(echo "${CIRCLE_REPOSITORY_URL}" | sed -E 's#(git@|https://)([^/:]+)[:/]([^/]+)/([^.]+)(\.git)?#https://\2/\3/\4#')
        echo "------------------------------------------------------"
        echo "üìù Computing Environment Variables"
        echo "------------------------------------------------------"
        echo "export PROFILE_NAME=<< parameters.cluster-name >>" | tee -a $BASH_ENV
        echo "export RELEASE_NAME=<< parameters.release-name >>" | tee -a $BASH_ENV
        echo "export ROLLOUT_NAME=<< parameters.release-name >>" | tee -a $BASH_ENV
        echo "export APPLICATION_NAME=<< parameters.release-name >>" | tee -a $BASH_ENV
        echo "export NAMESPACE=<< parameters.namespace >>" | tee -a $BASH_ENV
        echo "export APPLICATION_NAMESPACE=argocd" | tee -a $BASH_ENV
        echo "export REPOSITORY_HTTP_URL=$REPOSITORY_HTTP_URL" | tee -a $BASH_ENV
        echo "export HELM_DETECTION_DIR=/tmp/helm-detection" | tee -a $BASH_ENV

  - when:
      condition: << parameters.checkout >>
      steps:
        - checkout

  - update-kubeconfig-with-authenticator:
      cluster-name: << parameters.cluster-name >>
      aws-region: << parameters.region >>

  - run:
      name: Update helmv3 to v3.18.2
      command: |
        cd /tmp
        # SHA256 checksum for helm-v3.18.2-linux-amd64.tar.gz. Taken from https://github.com/helm/helm/releases/tag/v3.18.2
        EXPECTED_SHA256="c5deada86fe609deefdf40e9cbbe3da2f8cf3f6a4551a0ebe7886dc8fcf98bce"
        FILE_NAME="helm-v3.18.2-linux-amd64.tar.gz"
        # Try mirrors in order
        MIRRORS=(
          "https://get.helm.sh/${FILE_NAME}"
          "https://mirrors.huaweicloud.com/helm/v3.18.2/${FILE_NAME}"
        )
        DOWNLOAD_SUCCESS=false
        for MIRROR_URL in "${MIRRORS[@]}"; do
          echo "Attempting to download from: $MIRROR_URL"
          if curl -f -Lo "${FILE_NAME}" "${MIRROR_URL}" --retry 3 --retry-delay 1 --max-time 30; then
            # Validate SHA256 of downloaded file
            ACTUAL_SHA256=$(sha256sum "${FILE_NAME}" | cut -d' ' -f1)
            if [ "$ACTUAL_SHA256" = "$EXPECTED_SHA256" ]; then
              echo "‚úÖ SHA256 checksum validated successfully"
              DOWNLOAD_SUCCESS=true
              break
            else
              echo "‚ùå SHA256 checksum mismatch for $MIRROR_URL"
              echo "Expected: $EXPECTED_SHA256"
              echo "Got: $ACTUAL_SHA256"
              rm -f "${FILE_NAME}"
            fi
          else
            echo "‚ö†Ô∏è Failed to download from $MIRROR_URL, trying next mirror..."
          fi
        done
        if [ "$DOWNLOAD_SUCCESS" = false ]; then
          echo "‚ùå Error: Failed to download and validate Helm from all mirrors"
          exit 1
        fi
        tar -zxvf "${FILE_NAME}" && chmod +x ./linux-amd64/helm && sudo mv ./linux-amd64/helm /usr/local/bin/helmv3 && rm -rf ./linux-amd64 "${FILE_NAME}"
        helmv3 version

  - run:
      name: Install ArgoCD CLI
      command: |
        cd /tmp
        curl -LO https://github.com/argoproj/argo-cd/releases/download/v3.2.0/argocd-linux-amd64
        chmod +x ./argocd-linux-amd64
        sudo mv ./argocd-linux-amd64 /usr/local/bin/argocd
        argocd version --client

  - run:
      name: Install Argo Rollouts Kubectl plugin
      command: |
        cd /tmp
        curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
        chmod +x ./kubectl-argo-rollouts-linux-amd64
        sudo mv ./kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
        kubectl argo rollouts version

  - when:
      condition: << parameters.s3-chart-repo >>
      steps:
        - run:
            name: Add additional helm repo to helm v3
            command: |
              helmv3 repo add << parameters.s3-chart-repo >> s3://<< parameters.s3-chart-repo >>/
              helmv3 repo update

  - run:
      name: Detect old-school Helm version & chart name
      environment:
      command: <<include(scripts/detect_helm_version.sh)>>

  - when:
      condition: test -f /tmp/helm-detection/helm_backup_manifest.yaml
      steps:
        - store_artifacts:
            path: /tmp/helm-detection/helm_backup_manifest.yaml
            destination: helm-backup-manifest

  - run:
      name: Validate old-school Helm chart name
      command: |
        HELM_DETECTION_CHART_NAME_FILE=$HELM_DETECTION_DIR/chart_name
        previous_chart_name=$(cat $HELM_DETECTION_CHART_NAME_FILE)
        if [[ -n "$previous_chart_name" ]]; then
          case "$previous_chart_name" in
            microservices-v5 | microservices-v6 | microservices-v6-secrets-ext)
              # Valid chart names, continue
              ;;
            *)
              echo "‚ùå Error: Invalid previous_chart_name detected."
              echo "Allowed values are: 'microservices-v5', 'microservices-v6', 'microservices-v6-secrets-ext', or empty."
              echo "Please review your configuration and try again."
              exit 1
              ;;
          esac
        fi
        echo "------------------------------------------------------"
        echo "üìù Old-school chart name: $previous_chart_name"
        echo "------------------------------------------------------"

  - argo-migration-current-phase:
      release-name: << parameters.release-name >>
      values-file: << parameters.values-file >>
      namespace: << parameters.namespace >>
      image-tag: << parameters.image-tag >>
      chart: << parameters.chart >>
      args: <<#parameters.args>><<parameters.args>><</parameters.args>>
      mesh: << parameters.mesh >>

  - argo-deploy-application:
      release-name: << parameters.release-name >>
      values-file: << parameters.values-file >>
      namespace: << parameters.namespace >>
      image-tag: << parameters.image-tag >>
      args: <<#parameters.args>><<parameters.args>><</parameters.args>>
      mesh: << parameters.mesh >>
      destination-server: << parameters.destination-server >>
      set-path-annotation: << parameters.set-path-annotation >>
      s3-chart-repo: << parameters.s3-chart-repo >>
      helm-app-status-timeout: << parameters.helm-app-status-timeout >>
      rollout-status: << parameters.rollout-status >>
      rollout-status-timeout: << parameters.rollout-status-timeout >>
      project: << parameters.project >>
      old-school-chart-file: /tmp/helm-detection/chart_name

  - when:
      condition: << parameters.argocd-migration-workflow-enabled >>
      steps:
        - run:
            name: Triggers the ArgoCD migration workflow
            environment:
              PROJECT_REPO_NAME: ${CIRCLE_PROJECT_REPONAME}
              ROLLOUT_STATUS_TIMEOUT: << parameters.rollout-status-timeout >>
              ROLLOUT_STATUS_COMMON_SCRIPT: << include(scripts/argo_rollout_status_common.sh) >>
              ARGO_CLI_COMMON_SCRIPT: << include(scripts/argo_cli_common.sh) >>
              FEEDBACK_TIMEOUT: << parameters.argocd-migration-feedback-timeout >>
              FEEDBACK_ANNOTATION_KEY: migration.argocd.io/approval-next-phase
              FEEDBACK_CHECK_INTERVAL: 10
              ROLLOUT_STATUS_CHECK_INTERVAL: 10
            command: << include(scripts/argo_migration_workflow.sh) >>
